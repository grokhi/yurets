<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Юрец ФМ</title>
  <link rel="icon" href="/static/favicon.svg?v=2" type="image/svg+xml" />
  <link rel="icon" href="/static/favicon.svg?v=2" sizes="any" />
  <style>
    body {
      font-family: "Times New Roman", Times, serif;
      background: PeachPuff;
      color: black;
      margin: 200px 24px 24px 100px;
      padding-bottom: 56px;
    }
    h1 {
      font-family: "Times New Roman", Times, serif;
      font-size: 32px;
      margin: 0 0 12px 0;
      font-weight: bold;
    }
    .row { margin: 0 0 10px 0; }
    .label { font-weight: bold; }
    audio {
      display: block;
      margin-top: 6px;
    }
    #schedule {
      white-space: pre-line;
    }
    #queue {
      white-space: pre-line;
    }
    footer {
      /* font-weight: bold; */
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px 0;
      background: inherit;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Юрец ФМ</h1>

  <div class="row">
    <span class="label">Текущий трек:</span>
    <span id="now-playing">(загрузка...)</span>
  </div>

  <div class="row">
    <audio id="player" controls></audio>
  </div>

  <div class="row">
    <span class="label">Очередь:</span>
    <div id="queue">(загрузка...)</div>
  </div>

  <div class="row">
    <span class="label">Расписание:</span>
    <div id="schedule">(загрузка...)</div>
  </div>

  <footer>
    Powered by sovbak yeback experience.
  </footer>

  <script>
    (function () {
      // /stream — бесконечный запрос. В некоторых браузерах, если стартовать его слишком рано,
      // во вкладке остаётся индикатор "загрузки" вместо favicon.
      // Поэтому стартуем стрим после window.load.
      var player = document.getElementById("player");
      var streamAttached = false;
      var wantPlay = false;

      function attachStreamIfNeeded() {
        if (streamAttached) return;
        streamAttached = true;
        player.src = "/stream";
        if (player.load) player.load();
      }

      function safePlay() {
        if (!player.play) return;
        try {
          var p = player.play();
          if (p && p.catch) p.catch(function () {});
        } catch (e) {}
      }

      // Keep the old "attach after load" behavior to avoid favicon/infinite-loading quirks.
      // But also: if the user clicks play before window.load fires, attach immediately
      // and auto-resume when the stream becomes playable (no second click).
      window.addEventListener("load", function () {
        attachStreamIfNeeded();
      });

      function userRequestedPlay() {
        wantPlay = true;
        attachStreamIfNeeded();
        safePlay();
      }

      // First user gesture should reliably start playback.
      player.addEventListener("pointerdown", userRequestedPlay, { once: true });
      player.addEventListener(
        "keydown",
        function (e) {
          if (e && (e.key === " " || e.key === "Enter")) userRequestedPlay();
        },
        { once: true }
      );

      // If buffering takes time, retry play when it becomes possible.
      player.addEventListener("canplay", function () {
        if (wantPlay) safePlay();
      });
      player.addEventListener("loadeddata", function () {
        if (wantPlay) safePlay();
      });
      player.addEventListener("waiting", function () {
        if (wantPlay) safePlay();
      });
      player.addEventListener("playing", function () {
        // Playback successfully started.
        wantPlay = false;
      });
      player.addEventListener("pause", function () {
        // If the user pauses after playback started, don't auto-resume.
        // (If the stream was never playing, canplay/waiting handlers may still kick in.)
      });

      function esc(s) {
        return String(s || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function renderNowPlaying(data) {
        var parts = [];
        if (data && data.title) parts.push(esc(data.title));
        if (data && data.source) parts.push("<b>Источник:</b> " + esc(data.source));
        document.getElementById("now-playing").innerHTML = parts.join(" | ") || "(нет данных)";
      }

      function hhmmFromIso(iso) {
        if (!iso) return "";
        try {
          var d = new Date(String(iso));
          if (!isFinite(d.getTime())) return "";
          return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        } catch (e) {
          return "";
        }
      }

      function renderSchedule(data) {
        try {
          var slots = (data && data.slots) || [];
          if (!slots.length) {
            document.getElementById("schedule").textContent = "(нет расписания)";
            return;
          }

          var lines = slots.map(function (s) {
            if (s && s.start_at && s.end_at) {
              return hhmmFromIso(s.start_at) + "–" + hhmmFromIso(s.end_at) + " — " + (s.source || "");
            }
            // fallback (legacy)
            return String(s.start || "").slice(0, 5) + "–" + String(s.end || "").slice(0, 5) + " — " + (s.source || "");
          });
          document.getElementById("schedule").textContent = lines.join("\n");
        } catch (e) {
          document.getElementById("schedule").textContent = "(ошибка расписания)";
        }
      }

      async function loadSchedule() {
        try {
          var res = await fetch("/api/schedule", { cache: "no-store" });
          var data = await res.json();
          renderSchedule(data);
        } catch (e) {
          document.getElementById("schedule").textContent = "(ошибка запроса)";
        }
      }

      async function poll() {
        try {
          var res = await fetch("/api/now-playing", { cache: "no-store" });
          var data = await res.json();
          renderNowPlaying(data);
        } catch (e) {
          document.getElementById("now-playing").textContent = "(ошибка запроса)";
        }
      }

      function renderQueue(master) {
        try {
          var queue = master && master.queue;
          var tracks = (queue && queue.tracks) || [];
          tracks = tracks.slice(0, 5);
          if (!tracks.length) {
            document.getElementById("queue").textContent = "(пусто)";
            return;
          }

          var lines = [];
          for (var j = 0; j < tracks.length; j++) {
            lines.push(String(j + 1) + ". " + tracks[j]);
          }
          document.getElementById("queue").textContent = lines.join("\n");
        } catch (e) {
          document.getElementById("queue").textContent = "(ошибка очереди)";
        }
      }

      async function pollMaster() {
        try {
          var res = await fetch("/api/master?count=30&queue_count=5", { cache: "no-store" });
          var data = await res.json();
          renderQueue(data);
        } catch (e) {
          document.getElementById("queue").textContent = "(ошибка запроса)";
        }
      }

      poll();
      loadSchedule();
      pollMaster();
      setInterval(poll, 5000);
      setInterval(pollMaster, 15000);
    })();
  </script>
</body>
</html>
